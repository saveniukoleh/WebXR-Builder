{"version":3,"file":"js/61.5f89e029.js","mappings":"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","sources":["webpack://webxr-builder/./node_modules/three/examples/jsm/libs/motion-controllers.module.js","webpack://webxr-builder/./node_modules/three/examples/jsm/webxr/XRControllerModelFactory.js"],"sourcesContent":["/**\n * @webxr-input-profiles/motion-controllers 1.0.0 https://github.com/immersive-web/webxr-input-profiles\n */\n\nconst Constants = {\n  Handedness: Object.freeze({\n    NONE: 'none',\n    LEFT: 'left',\n    RIGHT: 'right'\n  }),\n\n  ComponentState: Object.freeze({\n    DEFAULT: 'default',\n    TOUCHED: 'touched',\n    PRESSED: 'pressed'\n  }),\n\n  ComponentProperty: Object.freeze({\n    BUTTON: 'button',\n    X_AXIS: 'xAxis',\n    Y_AXIS: 'yAxis',\n    STATE: 'state'\n  }),\n\n  ComponentType: Object.freeze({\n    TRIGGER: 'trigger',\n    SQUEEZE: 'squeeze',\n    TOUCHPAD: 'touchpad',\n    THUMBSTICK: 'thumbstick',\n    BUTTON: 'button'\n  }),\n\n  ButtonTouchThreshold: 0.05,\n\n  AxisTouchThreshold: 0.1,\n\n  VisualResponseProperty: Object.freeze({\n    TRANSFORM: 'transform',\n    VISIBILITY: 'visibility'\n  })\n};\n\n/**\n * @description Static helper function to fetch a JSON file and turn it into a JS object\n * @param {string} path - Path to JSON file to be fetched\n */\nasync function fetchJsonFile(path) {\n  const response = await fetch(path);\n  if (!response.ok) {\n    throw new Error(response.statusText);\n  } else {\n    return response.json();\n  }\n}\n\nasync function fetchProfilesList(basePath) {\n  if (!basePath) {\n    throw new Error('No basePath supplied');\n  }\n\n  const profileListFileName = 'profilesList.json';\n  const profilesList = await fetchJsonFile(`${basePath}/${profileListFileName}`);\n  return profilesList;\n}\n\nasync function fetchProfile(xrInputSource, basePath, defaultProfile = null, getAssetPath = true) {\n  if (!xrInputSource) {\n    throw new Error('No xrInputSource supplied');\n  }\n\n  if (!basePath) {\n    throw new Error('No basePath supplied');\n  }\n\n  // Get the list of profiles\n  const supportedProfilesList = await fetchProfilesList(basePath);\n\n  // Find the relative path to the first requested profile that is recognized\n  let match;\n  xrInputSource.profiles.some((profileId) => {\n    const supportedProfile = supportedProfilesList[profileId];\n    if (supportedProfile) {\n      match = {\n        profileId,\n        profilePath: `${basePath}/${supportedProfile.path}`,\n        deprecated: !!supportedProfile.deprecated\n      };\n    }\n    return !!match;\n  });\n\n  if (!match) {\n    if (!defaultProfile) {\n      throw new Error('No matching profile name found');\n    }\n\n    const supportedProfile = supportedProfilesList[defaultProfile];\n    if (!supportedProfile) {\n      throw new Error(`No matching profile name found and default profile \"${defaultProfile}\" missing.`);\n    }\n\n    match = {\n      profileId: defaultProfile,\n      profilePath: `${basePath}/${supportedProfile.path}`,\n      deprecated: !!supportedProfile.deprecated\n    };\n  }\n\n  const profile = await fetchJsonFile(match.profilePath);\n\n  let assetPath;\n  if (getAssetPath) {\n    let layout;\n    if (xrInputSource.handedness === 'any') {\n      layout = profile.layouts[Object.keys(profile.layouts)[0]];\n    } else {\n      layout = profile.layouts[xrInputSource.handedness];\n    }\n    if (!layout) {\n      throw new Error(\n        `No matching handedness, ${xrInputSource.handedness}, in profile ${match.profileId}`\n      );\n    }\n\n    if (layout.assetPath) {\n      assetPath = match.profilePath.replace('profile.json', layout.assetPath);\n    }\n  }\n\n  return { profile, assetPath };\n}\n\n/** @constant {Object} */\nconst defaultComponentValues = {\n  xAxis: 0,\n  yAxis: 0,\n  button: 0,\n  state: Constants.ComponentState.DEFAULT\n};\n\n/**\n * @description Converts an X, Y coordinate from the range -1 to 1 (as reported by the Gamepad\n * API) to the range 0 to 1 (for interpolation). Also caps the X, Y values to be bounded within\n * a circle. This ensures that thumbsticks are not animated outside the bounds of their physical\n * range of motion and touchpads do not report touch locations off their physical bounds.\n * @param {number} x The original x coordinate in the range -1 to 1\n * @param {number} y The original y coordinate in the range -1 to 1\n */\nfunction normalizeAxes(x = 0, y = 0) {\n  let xAxis = x;\n  let yAxis = y;\n\n  // Determine if the point is outside the bounds of the circle\n  // and, if so, place it on the edge of the circle\n  const hypotenuse = Math.sqrt((x * x) + (y * y));\n  if (hypotenuse > 1) {\n    const theta = Math.atan2(y, x);\n    xAxis = Math.cos(theta);\n    yAxis = Math.sin(theta);\n  }\n\n  // Scale and move the circle so values are in the interpolation range.  The circle's origin moves\n  // from (0, 0) to (0.5, 0.5). The circle's radius scales from 1 to be 0.5.\n  const result = {\n    normalizedXAxis: (xAxis * 0.5) + 0.5,\n    normalizedYAxis: (yAxis * 0.5) + 0.5\n  };\n  return result;\n}\n\n/**\n * Contains the description of how the 3D model should visually respond to a specific user input.\n * This is accomplished by initializing the object with the name of a node in the 3D model and\n * property that need to be modified in response to user input, the name of the nodes representing\n * the allowable range of motion, and the name of the input which triggers the change. In response\n * to the named input changing, this object computes the appropriate weighting to use for\n * interpolating between the range of motion nodes.\n */\nclass VisualResponse {\n  constructor(visualResponseDescription) {\n    this.componentProperty = visualResponseDescription.componentProperty;\n    this.states = visualResponseDescription.states;\n    this.valueNodeName = visualResponseDescription.valueNodeName;\n    this.valueNodeProperty = visualResponseDescription.valueNodeProperty;\n\n    if (this.valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM) {\n      this.minNodeName = visualResponseDescription.minNodeName;\n      this.maxNodeName = visualResponseDescription.maxNodeName;\n    }\n\n    // Initializes the response's current value based on default data\n    this.value = 0;\n    this.updateFromComponent(defaultComponentValues);\n  }\n\n  /**\n   * Computes the visual response's interpolation weight based on component state\n   * @param {Object} componentValues - The component from which to update\n   * @param {number} xAxis - The reported X axis value of the component\n   * @param {number} yAxis - The reported Y axis value of the component\n   * @param {number} button - The reported value of the component's button\n   * @param {string} state - The component's active state\n   */\n  updateFromComponent({\n    xAxis, yAxis, button, state\n  }) {\n    const { normalizedXAxis, normalizedYAxis } = normalizeAxes(xAxis, yAxis);\n    switch (this.componentProperty) {\n      case Constants.ComponentProperty.X_AXIS:\n        this.value = (this.states.includes(state)) ? normalizedXAxis : 0.5;\n        break;\n      case Constants.ComponentProperty.Y_AXIS:\n        this.value = (this.states.includes(state)) ? normalizedYAxis : 0.5;\n        break;\n      case Constants.ComponentProperty.BUTTON:\n        this.value = (this.states.includes(state)) ? button : 0;\n        break;\n      case Constants.ComponentProperty.STATE:\n        if (this.valueNodeProperty === Constants.VisualResponseProperty.VISIBILITY) {\n          this.value = (this.states.includes(state));\n        } else {\n          this.value = this.states.includes(state) ? 1.0 : 0.0;\n        }\n        break;\n      default:\n        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);\n    }\n  }\n}\n\nclass Component {\n  /**\n   * @param {Object} componentId - Id of the component\n   * @param {Object} componentDescription - Description of the component to be created\n   */\n  constructor(componentId, componentDescription) {\n    if (!componentId\n     || !componentDescription\n     || !componentDescription.visualResponses\n     || !componentDescription.gamepadIndices\n     || Object.keys(componentDescription.gamepadIndices).length === 0) {\n      throw new Error('Invalid arguments supplied');\n    }\n\n    this.id = componentId;\n    this.type = componentDescription.type;\n    this.rootNodeName = componentDescription.rootNodeName;\n    this.touchPointNodeName = componentDescription.touchPointNodeName;\n\n    // Build all the visual responses for this component\n    this.visualResponses = {};\n    Object.keys(componentDescription.visualResponses).forEach((responseName) => {\n      const visualResponse = new VisualResponse(componentDescription.visualResponses[responseName]);\n      this.visualResponses[responseName] = visualResponse;\n    });\n\n    // Set default values\n    this.gamepadIndices = Object.assign({}, componentDescription.gamepadIndices);\n\n    this.values = {\n      state: Constants.ComponentState.DEFAULT,\n      button: (this.gamepadIndices.button !== undefined) ? 0 : undefined,\n      xAxis: (this.gamepadIndices.xAxis !== undefined) ? 0 : undefined,\n      yAxis: (this.gamepadIndices.yAxis !== undefined) ? 0 : undefined\n    };\n  }\n\n  get data() {\n    const data = { id: this.id, ...this.values };\n    return data;\n  }\n\n  /**\n   * @description Poll for updated data based on current gamepad state\n   * @param {Object} gamepad - The gamepad object from which the component data should be polled\n   */\n  updateFromGamepad(gamepad) {\n    // Set the state to default before processing other data sources\n    this.values.state = Constants.ComponentState.DEFAULT;\n\n    // Get and normalize button\n    if (this.gamepadIndices.button !== undefined\n        && gamepad.buttons.length > this.gamepadIndices.button) {\n      const gamepadButton = gamepad.buttons[this.gamepadIndices.button];\n      this.values.button = gamepadButton.value;\n      this.values.button = (this.values.button < 0) ? 0 : this.values.button;\n      this.values.button = (this.values.button > 1) ? 1 : this.values.button;\n\n      // Set the state based on the button\n      if (gamepadButton.pressed || this.values.button === 1) {\n        this.values.state = Constants.ComponentState.PRESSED;\n      } else if (gamepadButton.touched || this.values.button > Constants.ButtonTouchThreshold) {\n        this.values.state = Constants.ComponentState.TOUCHED;\n      }\n    }\n\n    // Get and normalize x axis value\n    if (this.gamepadIndices.xAxis !== undefined\n        && gamepad.axes.length > this.gamepadIndices.xAxis) {\n      this.values.xAxis = gamepad.axes[this.gamepadIndices.xAxis];\n      this.values.xAxis = (this.values.xAxis < -1) ? -1 : this.values.xAxis;\n      this.values.xAxis = (this.values.xAxis > 1) ? 1 : this.values.xAxis;\n\n      // If the state is still default, check if the xAxis makes it touched\n      if (this.values.state === Constants.ComponentState.DEFAULT\n        && Math.abs(this.values.xAxis) > Constants.AxisTouchThreshold) {\n        this.values.state = Constants.ComponentState.TOUCHED;\n      }\n    }\n\n    // Get and normalize Y axis value\n    if (this.gamepadIndices.yAxis !== undefined\n        && gamepad.axes.length > this.gamepadIndices.yAxis) {\n      this.values.yAxis = gamepad.axes[this.gamepadIndices.yAxis];\n      this.values.yAxis = (this.values.yAxis < -1) ? -1 : this.values.yAxis;\n      this.values.yAxis = (this.values.yAxis > 1) ? 1 : this.values.yAxis;\n\n      // If the state is still default, check if the yAxis makes it touched\n      if (this.values.state === Constants.ComponentState.DEFAULT\n        && Math.abs(this.values.yAxis) > Constants.AxisTouchThreshold) {\n        this.values.state = Constants.ComponentState.TOUCHED;\n      }\n    }\n\n    // Update the visual response weights based on the current component data\n    Object.values(this.visualResponses).forEach((visualResponse) => {\n      visualResponse.updateFromComponent(this.values);\n    });\n  }\n}\n\n/**\n  * @description Builds a motion controller with components and visual responses based on the\n  * supplied profile description. Data is polled from the xrInputSource's gamepad.\n  * @author Nell Waliczek / https://github.com/NellWaliczek\n*/\nclass MotionController {\n  /**\n   * @param {Object} xrInputSource - The XRInputSource to build the MotionController around\n   * @param {Object} profile - The best matched profile description for the supplied xrInputSource\n   * @param {Object} assetUrl\n   */\n  constructor(xrInputSource, profile, assetUrl) {\n    if (!xrInputSource) {\n      throw new Error('No xrInputSource supplied');\n    }\n\n    if (!profile) {\n      throw new Error('No profile supplied');\n    }\n\n    this.xrInputSource = xrInputSource;\n    this.assetUrl = assetUrl;\n    this.id = profile.profileId;\n\n    // Build child components as described in the profile description\n    this.layoutDescription = profile.layouts[xrInputSource.handedness];\n    this.components = {};\n    Object.keys(this.layoutDescription.components).forEach((componentId) => {\n      const componentDescription = this.layoutDescription.components[componentId];\n      this.components[componentId] = new Component(componentId, componentDescription);\n    });\n\n    // Initialize components based on current gamepad state\n    this.updateFromGamepad();\n  }\n\n  get gripSpace() {\n    return this.xrInputSource.gripSpace;\n  }\n\n  get targetRaySpace() {\n    return this.xrInputSource.targetRaySpace;\n  }\n\n  /**\n   * @description Returns a subset of component data for simplified debugging\n   */\n  get data() {\n    const data = [];\n    Object.values(this.components).forEach((component) => {\n      data.push(component.data);\n    });\n    return data;\n  }\n\n  /**\n   * @description Poll for updated data based on current gamepad state\n   */\n  updateFromGamepad() {\n    Object.values(this.components).forEach((component) => {\n      component.updateFromGamepad(this.xrInputSource.gamepad);\n    });\n  }\n}\n\nexport { Constants, MotionController, fetchProfile, fetchProfilesList };\n","import {\n\tMesh,\n\tMeshBasicMaterial,\n\tObject3D,\n\tSphereGeometry,\n} from 'three';\n\nimport { GLTFLoader } from '../loaders/GLTFLoader.js';\n\nimport {\n\tConstants as MotionControllerConstants,\n\tfetchProfile,\n\tMotionController\n} from '../libs/motion-controllers.module.js';\n\nconst DEFAULT_PROFILES_PATH = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles';\nconst DEFAULT_PROFILE = 'generic-trigger';\n\nclass XRControllerModel extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.motionController = null;\n\t\tthis.envMap = null;\n\n\t}\n\n\tsetEnvironmentMap( envMap ) {\n\n\t\tif ( this.envMap == envMap ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.envMap = envMap;\n\t\tthis.traverse( ( child ) => {\n\n\t\t\tif ( child.isMesh ) {\n\n\t\t\t\tchild.material.envMap = this.envMap;\n\t\t\t\tchild.material.needsUpdate = true;\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Polls data from the XRInputSource and updates the model's components to match\n\t * the real world data\n\t */\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tif ( ! this.motionController ) return;\n\n\t\t// Cause the MotionController to poll the Gamepad for data\n\t\tthis.motionController.updateFromGamepad();\n\n\t\t// Update the 3D model to reflect the button, thumbstick, and touchpad state\n\t\tObject.values( this.motionController.components ).forEach( ( component ) => {\n\n\t\t\t// Update node data based on the visual responses' current states\n\t\t\tObject.values( component.visualResponses ).forEach( ( visualResponse ) => {\n\n\t\t\t\tconst { valueNode, minNode, maxNode, value, valueNodeProperty } = visualResponse;\n\n\t\t\t\t// Skip if the visual response node is not found. No error is needed,\n\t\t\t\t// because it will have been reported at load time.\n\t\t\t\tif ( ! valueNode ) return;\n\n\t\t\t\t// Calculate the new properties based on the weight supplied\n\t\t\t\tif ( valueNodeProperty === MotionControllerConstants.VisualResponseProperty.VISIBILITY ) {\n\n\t\t\t\t\tvalueNode.visible = value;\n\n\t\t\t\t} else if ( valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM ) {\n\n\t\t\t\t\tvalueNode.quaternion.slerpQuaternions(\n\t\t\t\t\t\tminNode.quaternion,\n\t\t\t\t\t\tmaxNode.quaternion,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t);\n\n\t\t\t\t\tvalueNode.position.lerpVectors(\n\t\t\t\t\t\tminNode.position,\n\t\t\t\t\t\tmaxNode.position,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n * Walks the model's tree to find the nodes needed to animate the components and\n * saves them to the motionContoller components for use in the frame loop. When\n * touchpads are found, attaches a touch dot to them.\n */\nfunction findNodes( motionController, scene ) {\n\n\t// Loop through the components and find the nodes needed for each components' visual responses\n\tObject.values( motionController.components ).forEach( ( component ) => {\n\n\t\tconst { type, touchPointNodeName, visualResponses } = component;\n\n\t\tif ( type === MotionControllerConstants.ComponentType.TOUCHPAD ) {\n\n\t\t\tcomponent.touchPointNode = scene.getObjectByName( touchPointNodeName );\n\t\t\tif ( component.touchPointNode ) {\n\n\t\t\t\t// Attach a touch dot to the touchpad.\n\t\t\t\tconst sphereGeometry = new SphereGeometry( 0.001 );\n\t\t\t\tconst material = new MeshBasicMaterial( { color: 0x0000FF } );\n\t\t\t\tconst sphere = new Mesh( sphereGeometry, material );\n\t\t\t\tcomponent.touchPointNode.add( sphere );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( `Could not find touch dot, ${component.touchPointNodeName}, in touchpad component ${component.id}` );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Loop through all the visual responses to be applied to this component\n\t\tObject.values( visualResponses ).forEach( ( visualResponse ) => {\n\n\t\t\tconst { valueNodeName, minNodeName, maxNodeName, valueNodeProperty } = visualResponse;\n\n\t\t\t// If animating a transform, find the two nodes to be interpolated between.\n\t\t\tif ( valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM ) {\n\n\t\t\t\tvisualResponse.minNode = scene.getObjectByName( minNodeName );\n\t\t\t\tvisualResponse.maxNode = scene.getObjectByName( maxNodeName );\n\n\t\t\t\t// If the extents cannot be found, skip this animation\n\t\t\t\tif ( ! visualResponse.minNode ) {\n\n\t\t\t\t\tconsole.warn( `Could not find ${minNodeName} in the model` );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! visualResponse.maxNode ) {\n\n\t\t\t\t\tconsole.warn( `Could not find ${maxNodeName} in the model` );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// If the target node cannot be found, skip this animation\n\t\t\tvisualResponse.valueNode = scene.getObjectByName( valueNodeName );\n\t\t\tif ( ! visualResponse.valueNode ) {\n\n\t\t\t\tconsole.warn( `Could not find ${valueNodeName} in the model` );\n\n\t\t\t}\n\n\t\t} );\n\n\t} );\n\n}\n\nfunction addAssetSceneToControllerModel( controllerModel, scene ) {\n\n\t// Find the nodes needed for animation and cache them on the motionController.\n\tfindNodes( controllerModel.motionController, scene );\n\n\t// Apply any environment map that the mesh already has set.\n\tif ( controllerModel.envMap ) {\n\n\t\tscene.traverse( ( child ) => {\n\n\t\t\tif ( child.isMesh ) {\n\n\t\t\t\tchild.material.envMap = controllerModel.envMap;\n\t\t\t\tchild.material.needsUpdate = true;\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t// Add the glTF scene to the controllerModel.\n\tcontrollerModel.add( scene );\n\n}\n\nclass XRControllerModelFactory {\n\n\tconstructor( gltfLoader = null ) {\n\n\t\tthis.gltfLoader = gltfLoader;\n\t\tthis.path = DEFAULT_PROFILES_PATH;\n\t\tthis._assetCache = {};\n\n\t\t// If a GLTFLoader wasn't supplied to the constructor create a new one.\n\t\tif ( ! this.gltfLoader ) {\n\n\t\t\tthis.gltfLoader = new GLTFLoader();\n\n\t\t}\n\n\t}\n\n\tcreateControllerModel( controller ) {\n\n\t\tconst controllerModel = new XRControllerModel();\n\t\tlet scene = null;\n\n\t\tcontroller.addEventListener( 'connected', ( event ) => {\n\n\t\t\tconst xrInputSource = event.data;\n\n\t\t\tif ( xrInputSource.targetRayMode !== 'tracked-pointer' || ! xrInputSource.gamepad ) return;\n\n\t\t\tfetchProfile( xrInputSource, this.path, DEFAULT_PROFILE ).then( ( { profile, assetPath } ) => {\n\n\t\t\t\tcontrollerModel.motionController = new MotionController(\n\t\t\t\t\txrInputSource,\n\t\t\t\t\tprofile,\n\t\t\t\t\tassetPath\n\t\t\t\t);\n\n\t\t\t\tconst cachedAsset = this._assetCache[ controllerModel.motionController.assetUrl ];\n\t\t\t\tif ( cachedAsset ) {\n\n\t\t\t\t\tscene = cachedAsset.scene.clone();\n\n\t\t\t\t\taddAssetSceneToControllerModel( controllerModel, scene );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( ! this.gltfLoader ) {\n\n\t\t\t\t\t\tthrow new Error( 'GLTFLoader not set.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.gltfLoader.setPath( '' );\n\t\t\t\t\tthis.gltfLoader.load( controllerModel.motionController.assetUrl, ( asset ) => {\n\n\t\t\t\t\t\tthis._assetCache[ controllerModel.motionController.assetUrl ] = asset;\n\n\t\t\t\t\t\tscene = asset.scene.clone();\n\n\t\t\t\t\t\taddAssetSceneToControllerModel( controllerModel, scene );\n\n\t\t\t\t\t},\n\t\t\t\t\tnull,\n\t\t\t\t\t() => {\n\n\t\t\t\t\t\tthrow new Error( `Asset ${controllerModel.motionController.assetUrl} missing or malformed.` );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} ).catch( ( err ) => {\n\n\t\t\t\tconsole.warn( err );\n\n\t\t\t} );\n\n\t\t} );\n\n\t\tcontroller.addEventListener( 'disconnected', () => {\n\n\t\t\tcontrollerModel.motionController = null;\n\t\t\tcontrollerModel.remove( scene );\n\t\t\tscene = null;\n\n\t\t} );\n\n\t\treturn controllerModel;\n\n\t}\n\n}\n\nexport { XRControllerModelFactory };\n"],"names":["Constants","Handedness","Object","freeze","NONE","LEFT","RIGHT","ComponentState","DEFAULT","TOUCHED","PRESSED","ComponentProperty","BUTTON","X_AXIS","Y_AXIS","STATE","ComponentType","TRIGGER","SQUEEZE","TOUCHPAD","THUMBSTICK","ButtonTouchThreshold","AxisTouchThreshold","VisualResponseProperty","TRANSFORM","VISIBILITY","async","fetchJsonFile","path","response","fetch","ok","json","Error","statusText","fetchProfilesList","basePath","profileListFileName","profilesList","fetchProfile","xrInputSource","defaultProfile","getAssetPath","supportedProfilesList","match","profiles","some","profileId","supportedProfile","profilePath","deprecated","profile","assetPath","layout","handedness","layouts","keys","replace","defaultComponentValues","xAxis","yAxis","button","state","normalizeAxes","x","y","hypotenuse","Math","sqrt","theta","atan2","cos","sin","result","normalizedXAxis","normalizedYAxis","VisualResponse","constructor","visualResponseDescription","this","componentProperty","states","valueNodeName","valueNodeProperty","minNodeName","maxNodeName","value","updateFromComponent","includes","Component","componentId","componentDescription","visualResponses","gamepadIndices","length","id","type","rootNodeName","touchPointNodeName","forEach","responseName","visualResponse","assign","values","undefined","data","updateFromGamepad","gamepad","buttons","gamepadButton","pressed","touched","axes","abs","MotionController","assetUrl","layoutDescription","components","gripSpace","targetRaySpace","component","push","DEFAULT_PROFILES_PATH","DEFAULT_PROFILE","XRControllerModel","Object3D","super","motionController","envMap","setEnvironmentMap","traverse","child","isMesh","material","needsUpdate","updateMatrixWorld","force","valueNode","minNode","maxNode","MotionControllerConstants","visible","quaternion","slerpQuaternions","position","lerpVectors","findNodes","scene","touchPointNode","getObjectByName","sphereGeometry","SphereGeometry","MeshBasicMaterial","color","sphere","Mesh","add","console","warn","addAssetSceneToControllerModel","controllerModel","XRControllerModelFactory","gltfLoader","_assetCache","GLTFLoader","createControllerModel","controller","addEventListener","event","targetRayMode","then","cachedAsset","clone","setPath","load","asset","catch","err","remove"],"sourceRoot":""}